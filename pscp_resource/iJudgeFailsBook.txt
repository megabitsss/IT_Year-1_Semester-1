i<Judge> fails textbook
#1 ลืมใช้ _ แทน i เวลาไม่ใช้ใน loop
#2 ลืมอ่านว่า range ของ input มีจำนวนอะไรบ้าง
#3 ถ้ากำหนดค่าตัวแปรนอกฟังก์ชั่น จะกลายเป็น constant ซึ่งต้องเป็นตัวพิมพ์ใหญ่เท่านั้น
#4 ลืม docstring เวลาเขียนฟังก์ชั่นอื่นที่ไม่ใช่ main
#5 python จะไม่ค่อยในิยมใช้ camelCase (มีก็ใน method ของ class) จะเน้นเป็น snake_case มากกว่า ฉะนั้นถ้าเลี่ยงได้เลี่ยงสำหรับ camelCase 
#6 ไม่จำเป็นต้องใช้ if -> return, else -> return ให้ใช้ if -> return, return ได้เลย เพราะยังไง return แล้วก็จบ func อยู่ดี
#7 เขียนโดยใช้คำในบรรทัดยาวเกิน (ต้องไม่เกิน 100 char) ให้เขียนไปก่อนแล้วค่อยใช้ \ มาขึ้นบรรทัดต่อ
#8 ใส่ parameter ในฟังก์ชั่นมากเกินไป วิธีแก้คือรับมาแล้วใส่วงเล็บคลุมให้ ส่วนใน parameter ให้เก็บใส่เป็น tuple แล้วค่อยไปแยกใส่ในตัวแปรอีกที
#9 sum จะเอามาตั้งชื่อตัวแปรไม่ได้ (ซ้ำ built-in func) ให้ใช้ sumz, sums แทน
#10 ใน loop จะรันแบบถอยหลัง แต่ลืมให้ step = -1
#11 จะเอาค่า j ปริ้นแต่เอา i มาใช้แทน
#12 ถ้า start = 0 , stop = 0 ก็แปลว่า loop มันจะไม่เริ่มทำงานอยู่แล้ว
#13 การสรุปว่า x1,x2,x3 แล้ว x1 มากสุดจะใช้หลักการ x1>x2>x3 ไม่ได้ เช่น กรณี 7 > 3 > 5. x1 มากสุดก็จริงแต่เงื่อนไขโดยรวม จะเป็นเท็จอยู่ดี เพราะ 3>5 ไม่จริง ทั้งหมดเลยไม่จริง แต่ถ้าเราใช้ x1 > x2 and x1 > x3 จะสรุปได้ทันทีแบบตรงตัว
#14 if j in (1, i, n) ความหมายเดียวกันกับ if j==1 or j==i or j==n แต่ใช้แบบแรกจะถูกตาม pep8
#15 ระวังเรื่อง global and local scope โปรแกรมจะใช้ตัวแปรใน scope ที่ใกล้สุดก่อน
#16 match case จะไม่มี "or" ให้ใช้ " | " แทน
#17 อ่าน restricted words ดีๆก่อนทำ จะได้ไม่เสียเวลา
#18 range() มี step ควรใช้ให้เกิดประโยชน์
#19 ยังอ่านโจทย์ต้องการอะไร เลยทำผิด ก็เลยผิดหมด ควรตีความโจทย์ให้ดีกว่านี้ก่อน
#20 ใช้ math.ceil() and math.floor() สลับกัน
#21 ลืม docstring เวลาสร้าง func มาใหม่อีกอัน
#22 โจทย์ข้อ it business ลืมคำว่า "ติดต่อกัน" ในตอนเช็คการทำธุรกรรม
#23 เรียงลำดับการ input, การ break ใน while loop ไม่ถูกทำให้มารอ input เพิ่มใหม่อีกครั้ง ทั้งๆที่ควรจะจบ loop ไปแล้ว เป็นสาเหตุที่เกิด EOF error**
#24 ลืมข้อ 16 เรื่องการใช้ | ใน match-case
#25 เผลอใช้ชื่อฟังก์ชั่น มาตั้งเป็นชื่อตัวแปรใหม่อีกรอบ
#26 or n == 0 เปลี่ยนเป็น or not n ได้
#27 ลืมการเขียน if-elif-else ที่เขียนฟังก์ชั่นแบบมีการ return ว่าเขียนแบบ if condition ไปอย่างเดียวเลยก็ได้
#28 ljust / rljust.(spaces, word to padding) justify ข้อความไปทาง l/r ด้วย(space พื้นที่ทั้งหมด, อักษรที่จะเอามา padding) ก็คือ padding ข้อความนั่นแหละ
#29 find() / rfind() paremeter(value, start, stop) paremeter เหมือนกัน หน้าที่คือvalue ที่เราต้องการในช่วง range(start, stop) find() ถ้าเจอคือจะเอาซ้ายสุด ส่วน rfind() ถ้าเจอจะขวาสุด มาจากคำว่า reversed find
#30 range(3, 0, -1) กับ tuple (3, 2, 1) ใช้ได้เหมือนกัน
#31 ไม่ดู requirements โจทย์ให้ดีว่าต้องการ print แบบไหน ex.แบบบรรทัดเดียว, list, เว้นบรรทัด (เราผิดบ่อยตอนใช้ list)
#32 ถ้าเป็น list เปล่าค่า boolean จะเป็น False, แต่ถ้ามี element จะเป็น True (ระหว่างเรื่อง pep-8)
#33 เราถ้ามี my_list = [1, 2, 3] แล้วจะเอาเรามารับ เราเขียนนี้ได้เลย x, y, z = [1, 2, 3] ไม่ต้องไป referencing index อยู่
#34 ถ้ามี element ที่เหมือนกันสองตัวหมดเลย แต่ตัวนึงมีสมาชิกกว่าหนึ่งตัว เช่น [("a", "1", "e"), ("a", "1")] เวลา sort แล้วจะได้ [("a", "1"), ("a", "1", "e")] เพราะ ("a", "1") ถือว่ามี element น้อยกว่า -> เล็กกว่า
#35 เวลา sort -> key เราสามารถมีหลาย parameter ได้ ซึ่งหมายความเราอยาก sort ด้วยเงื่อนไขใดก่อน เช่น key = (primary criterion, second criterion) ไปเรื่อยๆ ประมาณนี้
#36 คำสั่ง "SEPERATOR".join() เอาไว้ใช้คือ รวมแต่ละ element เป็น string ตัวเดียว เช่น A = ["Hello", "Bro"] ถ้าใช้ " ".join(A) มันจะรวมแต่ละตัวใน list มาแล้วคั่นแต่ละตัวด้วย separator (whitespace ที่เราใส่ไว้หน้า join) ซึ่งจะได้ข้อความ Hello Bro มาเป็น string ก้อนเดียวเลย (หรือเราอยากจะเปลี่ยน separator ก็ได้แล้วแต่เราเลย)
#37 สามารถเขียน type hit เช่น def vowel_counter(txt: str) -> int: ได้ หมายความว่าเราจะรับ txt เป็น str, return เป็น int ซึ่งเป็น hint เฉยๆ ถ้าเรากรอกผิดมันก็ไม่ได้เตือนอะไร (แต่จะมีผลตอน autocomplete in text editor เพราะมันช่วยให้เราเขียนได้ง่ายขึ้น)
#38 แปลง list -> tuple ได้โดยการ a = [1, 2, 3], b = tuple(a) -> b = (1, 2, 3)
#39 คำสั่ง map คือจะเปลี่ยนค่า element ใน iterable ทั้งหมดด้วยการใช้ map(function, iterable_1, iterable_2, ...) เช่นอาจจะใช้เป็น int ทุกค่าใน iterable ก็จะเปลี่ยนเป็น int แต่พอเราใช้ map(..) ค่าที่ได้จะเป็น object Map เราต้องแปลงโดยการใช้ list(map(..)) / tuple(map(..)), etc.
#40 ถ้าเรา a = [1, 2, 3], b = [4, 5, 6] ถ้าเราเอา a + b จะเป็นการ concatenate list ซึ่งจะได้ [1, 2, 3, 4, 5, 6]
#41 list.remove("value") จะลบค่าแรกที่ใน list ออกไป
#42 zip(iterable1, iterable2, iterable3, ..) จะรวมหลายตัวให้เป็นตัวเดียวกันแบบนี้ a = ("John", "Charles", "Mike"), b = ("Jenny", "Christy", "Monica") zipped -> (('John', 'Jenny'), ('Charles', 'Christy'), ('Mike', 'Monica')) (ได้เป็น object zip ซึ่งต้องเอาไปแปลงเป็น list,tuple ต่อ)
#43 Boolean False มีค่าน้อยกว่า True (ใช้ในเรื่อง Sort ได้)
#44 ถ้า slice string แล้วเกินจะไม่เจออะไร เช่น "Hello"[100:] จะไม่เจออะไร (string เปล่า) แต่ถ้าอ้างอิงเฉยๆ Hello[100] จะ Error; index out of range แทน
#45 ถ้าเรา remove item ใน list ขณะ travesing item ใน list นั้น จะทำให้เกิด error ได้ (index มีการเปลี่ยน) อาจจะแก้โดยการ .copy() / [:] แทน
#46 * เป็น operator ที่สามารถ unpack argument ได้ เช่น การส่งหาในฟังก์ชั่นที่มี 2 args แบบนี้ x = (1, 2) func(x) แบบนี้จะ Error เพราะ x ถือเป็น arg เดียว วิธีแก้สามารถใช้ * มา unpack variable ได้